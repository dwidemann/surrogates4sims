#AUTOGENERATED! DO NOT EDIT! File to edit: dev/01_pnnl_dataset.ipynb (unless otherwise specified).

__all__ = ['plotData', 'interpData', 'plotFrame', 'CCSI_2D', 'preprocessFcn', 'inversePreprocessFcn', 'getInt']

#Cell
#from torchvision import datasets, transforms
import os, sys
from glob import glob
import pickle
import numpy as np
import torch
from torch.utils.data import Dataset, DataLoader
import matplotlib.pyplot as plt
from random import shuffle
from tqdm import tqdm
import pandas as pd
from scipy.interpolate import interp2d, griddata
from mpl_toolkits.axes_grid1 import make_axes_locatable
import re

#Cell
def plotData(grid_x, grid_y, grid_z, title, pngFile=None):
    plt.figure()
    ax = plt.gca()
    im = ax.pcolormesh(grid_y,grid_x, grid_z, cmap='RdYlBu')
    plt.axes().set_aspect('equal')
    plt.title(title)
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(im, cax=cax)
    plt.show()
    if pngFile:
        plt.savefig(pngFile, dpi=300)
        plt.close()

def interpData(x,y,z,Nx=None,Ny=None,delta_x=None,nextPow2=False,method='linear'):
    '''
    This function takes 3 lists of points (x,y,z) and maps them to a
    rectangular grid. Either Nx or Ny must be set or delta_x must be set.
    e.g.

    x = y = z = np.random.rand(30)
    grid_x, grid_y, grid_z = interpData(x,y,z,Nx=128,Ny=128)

    or

    grid_x, grid_y, grid_z = interpData(x,y,z,delta_x=1e-3,nextPow2=True)
    '''

    eps = 1e-4 # needed to make sure that the interpolation does not have nans.
    def _NextPowerOfTwo(number):
        # Returns next power of two following 'number'
        return np.ceil(np.log2(number))

    if Nx == None and Ny == None:
        assert delta_x != None
        delta_y = delta_x
        Nx = int((x.max() - x.min())/delta_x)
        Ny = int((y.max() - y.min())/delta_y)

    if nextPow2:
        Nx = 2**_NextPowerOfTwo(Nx)
        Ny = 2**_NextPowerOfTwo(Ny)

    grid_x, grid_y = np.mgrid[x.min()+eps:x.max()-eps:Nx*1j,y.min()+eps:y.max()-eps:Ny*1j]
    grid_z = griddata(np.array([x,y]).T, z, (grid_x, grid_y), method=method)
    return grid_x, grid_y, grid_z

def plotFrame(fn):
    D = pd.read_csv(fn)
    x = D['X (m)']
    y = D['Y (m)']
    for d in D.columns[:4]:
        z = D[d]
        grid_x, grid_y, grid_z = interpData(x.values,y.values,z.values,delta_x=1e-4)
        idx = getInt(fn)
        d = d.replace(' ','_')
        d = re.sub(r'[^A-Za-z0-9 ]+', '_', d)[:-1]
        title = '{}, Time Step: {}'.format(d,idx)
        pngFile = '{}_{}.png'.format(d,idx)
        plotData(grid_y, grid_x, grid_z, title, pngFile)


class CCSI_2D(Dataset):
    def __init__(self,
                 dataDirec='/data/ccsi/PNNLTimeStepData/001a/',
                 numToKeep=np.infty,transform=None,preprocess=True,
                 Nx=None,Ny=None,delta_x=None,nextPow2=True,interpMethod='linear',
                 channel=None):

        self.data = []
        self.files = []
        self.delta_x = delta_x
        self.nextPow2 = nextPow2
        self.Nx = Nx
        self.Ny = Ny
        self.grid_x = []
        self.grid_y = []
        self.preprocess = preprocess
        self.interpMethod = interpMethod
        self.channel = channel

        if type(dataDirec) == list:
            self.files = dataDirec
        elif 'pkl' in dataDirec:
            with open(dataDirec,'rb') as fid:
                D = pickle.load(fid)
                self.data = np.array(D['data'])
                self.grid_x = D['grid_x']
                self.grid_y = D['grid_y']
                if numToKeep < len(self.data):
                     self.data = self.data[:numToKeep]
        else:
            files = glob(os.path.join(dataDirec,'*.csv'))
            L = np.argsort(list(map(getInt,files)))
            self.files = [files[i] for i in L]

        self.dataDirec = dataDirec
        self.numToKeep = numToKeep
        self.transform = transform
        self.preprocess = preprocess
        self.column = []


        if self.files is not []:
            if numToKeep < len(self.files):
                self.files = self.files[:numToKeep]

            for f in self.files:
                self.data.append(self.loadfile(f))

        if preprocess:
            for i, d in enumerate(self.data):
                self.data[i] = self.preprocessFcn(d)

    def loadfile(self,fn):
        D = pd.read_csv(fn)
        x = D['X (m)'].values.astype('float32')
        y = D['Y (m)'].values.astype('float32')
        X = []
        for d in D.columns[:4]:
            z = D[d].values.astype('float32')
            grid_x, grid_y, grid_z = interpData(x,y,z,
                                                self.Nx,self.Ny,
                                                self.delta_x,self.nextPow2,
                                                self.interpMethod)
            X.append(grid_z)

        self.grid_x = grid_x
        self.grid_y = grid_y
        self.column = D.columns[:4]
        return np.array(X).astype('float32')


    def preprocessFcn(self, X,mx=[5.46,4.1,1.,2012.],
                      mn=[-4.8, -8.8,0.,-1725.]):
        # mx and mn are the maximums and minimums
        # of the original data's 4 channels.
        assert len(X) == 4
        Xnew = np.empty_like(X)
        cnt = 0
        for x,M,m in zip(X,mx,mn):
            Xnew[cnt] = 2*((x-m)/(M-m) - .5)
            cnt += 1
        return Xnew

    def inversePreprocessFcn(self, X,mx=[5.46,4.1,1.,2012.],
                             mn=[-4.8, -8.8,0.,-1725.]):
        assert len(X) == 4
        Xnew = np.empty_like(X)
        cnt = 0
        for x,M,m in zip(X,mx,mn):
            Xnew[cnt] = (M - m)*((x/2) + .5) + m
            cnt += 1
        return Xnew

    def __len__(self):
        return len(self.data)


    def plotData(self,idx,pngFile=None):
        D = self.data[idx]
        for i in range(4):
            grid_z = D[i]
            plt.figure()
            ax = plt.gca()
            im = ax.pcolormesh(self.grid_x,self.grid_y, grid_z, cmap='RdYlBu')
            plt.axes().set_aspect('equal')
            plt.title('Sample {}, {}'.format(idx,self.column[i]))
            divider = make_axes_locatable(ax)
            cax = divider.append_axes("right", size="5%", pad=0.05)
            plt.colorbar(im, cax=cax)
            if pngFile:
                plt.savefig(pngFile, dpi=300)
                plt.close()

    def __getitem__(self, idx):
        X  = self.data[idx].astype('float32')
        if self.channel is not None:
            X = X[self.channel,:,:]
            X = X[np.newaxis]

        if self.transform is not None:
            X = self.transform(X)
        return X,X # this allows LR_finder to work


# these functions are in the class too
def preprocessFcn(X,mx=[5.46,4.1,1.,2012.],
                 mn=[-4.8, -8.8,0.,-1725.]):
    # maps the X to [-1,1]
    assert len(X) == 4
    Xnew = np.empty_like(X)
    cnt = 0
    for x,M,m in zip(X,mx,mn):
        Xnew[cnt] = 2*((x-m)/(M-m) - .5)
        cnt += 1
    return Xnew

def inversePreprocessFcn(X,mx=[5.46,4.1,1.,2012.],
                 mn=[-4.8, -8.8,0.,-1725.]):
    Xnew = np.empty_like(X)
    cnt = 0
    for x,M,m in zip(X,mx,mn):
        Xnew[cnt] = (M - m)*((x/2) + .5) + m
        cnt += 1
    return Xnew



#Cell
def getInt(f):
    return int(f.split('_')[-1].replace('.csv',''))