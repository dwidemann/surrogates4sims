#AUTOGENERATED! DO NOT EDIT! File to edit: dev/01_pnnl_dataset.ipynb (unless otherwise specified).

__all__ = ['plotData', 'interpData', 'plotFrame', 'CCSI_2D', 'CCSI_2D_old', 'preprocessFcn', 'inversePreprocessFcn',
           'getInt', 'sumLineSegments', 'computeInterfacialArea']

#Cell
#from torchvision import datasets, transforms
import os, sys
from glob import glob
import pickle
import numpy as np
import torch
from torch.utils.data import Dataset, DataLoader
import matplotlib.pyplot as plt
from random import shuffle
from tqdm import tqdm
import pandas as pd
from scipy.interpolate import interp2d, griddata
from mpl_toolkits.axes_grid1 import make_axes_locatable
import re
from .utils import pkl_load, pkl_save
from tqdm import tqdm

#Cell
def plotData(grid_x, grid_y, grid_z, title, pngFile=None):
    plt.figure()
    ax = plt.gca()
    im = ax.pcolormesh(grid_y,grid_x, grid_z, cmap='RdYlBu')
    plt.axes().set_aspect('equal')
    plt.title(title)
    divider = make_axes_locatable(ax)
    cax = divider.append_axes("right", size="5%", pad=0.05)
    plt.colorbar(im, cax=cax)
    plt.show()
    if pngFile:
        plt.savefig(pngFile, dpi=300)
        plt.close()

def interpData(x,y,z,Nx=None,Ny=None,delta_x=None,nextPow2=False,method='linear'):
    '''
    This function takes 3 lists of points (x,y,z) and maps them to a
    rectangular grid. Either Nx or Ny must be set or delta_x must be set.
    e.g.

    x = y = z = np.random.rand(30)
    grid_x, grid_y, grid_z = interpData(x,y,z,Nx=128,Ny=128)

    or

    grid_x, grid_y, grid_z = interpData(x,y,z,delta_x=1e-3,nextPow2=True)
    '''

    eps = 1e-4 # needed to make sure that the interpolation does not have nans.
    def _NextPowerOfTwo(number):
        # Returns next power of two following 'number'
        return np.ceil(np.log2(number))

    if Nx == None and Ny == None:
        assert delta_x != None
        delta_y = delta_x
        Nx = int((x.max() - x.min())/delta_x)
        Ny = int((y.max() - y.min())/delta_y)

    if nextPow2:
        Nx = 2**_NextPowerOfTwo(Nx)
        Ny = 2**_NextPowerOfTwo(Ny)

    grid_x, grid_y = np.mgrid[x.min()+eps:x.max()-eps:Nx*1j,y.min()+eps:y.max()-eps:Ny*1j]
    grid_z = griddata(np.array([x,y]).T, z, (grid_x, grid_y), method=method)
    return grid_x, grid_y, grid_z

def plotFrame(fn):
    D = pd.read_csv(fn)
    x = D['X (m)']
    y = D['Y (m)']
    for d in D.columns[:4]:
        z = D[d]
        grid_x, grid_y, grid_z = interpData(x.values,y.values,z.values,delta_x=1e-4)
        idx = getInt(fn)
        d = d.replace(' ','_')
        d = re.sub(r'[^A-Za-z0-9 ]+', '_', d)[:-1]
        title = '{}, Time Step: {}'.format(d,idx)
        pngFile = '{}_{}.png'.format(d,idx)
        plotData(grid_y, grid_x, grid_z, title, pngFile)


class CCSI_2D(Dataset):
    def __init__(self,
                 dataFiles,
                 txtFile = '/data/ccsi/pnnl_liquid_inlet/liquid_inlet_velocity.txt',
                 channel=1,
                 gridSize=128,
                 simLen = 500,
                 w = 10, # this is the length of the Y output to predict
                 AE = False, # this only return x,x, i.e. no y.
                 numToKeep=np.infty,doPreprocess=False):

        self.dataFiles = dataFiles
        if numToKeep < len(self.dataFiles):
            self.dataFiles = self.dataFiles[:numToKeep]

        self.channel = channel
        self.gridSize = gridSize
        self.numToKeep = numToKeep
        self.simLen = simLen
        self.t = np.linspace(0,1,simLen).astype('float32')
        self.w = w
        self.AE = AE
        self.doPreprocess = doPreprocess

        # Get the inlet velocity
        with open(txtFile) as fid:
            txt = fid.read().splitlines()
        inletVelocity = np.array(list(map(float,txt[1:]))).astype('float32')
        self.inletMx = np.max(inletVelocity)
        self.inletMn = np.min(inletVelocity)
#         inds = list(map(lambda x: int(x.split('/')[-1].replace('.pkl','')) - 1,self.dataFiles))
#         self.inletVelocity = inletVelocity[inds]

        data = []
        for fn in self.dataFiles:
            idx = int(fn.split('/')[-1].replace('.pkl','')) - 1
            D = pkl_load(fn)
            data.append((D,inletVelocity[idx]))

        self.data = data
#         if preprocess:
#             for i, d in enumerate(self.data):
#                 self.data[i] = self.preprocessFcn(d)

#     def preprocessFcn(self, X,mx=[5.46,4.1,1.,2012.],
#                       mn=[-4.8, -8.8,0.,-1725.]):
#         # mx and mn are the maximums and minimums
#         # of the original data's 4 channels.
#         Xnew = np.empty_like(X)
#         cnt = 0
#         for x,M,m in zip(X,mx,mn):
#             Xnew[cnt] = 2*((x-m)/(M-m) - .5)
#             cnt += 1
#         return Xnew

#     def inversePreprocessFcn(self, X,mx=[5.46,4.1,1.,2012.],
#                              mn=[-4.8, -8.8,0.,-1725.]):
#         Xnew = np.empty_like(X)
#         cnt = 0
#         for x,M,m in zip(X,mx,mn):
#             Xnew[cnt] = (M - m)*((x/2) + .5) + m
#             cnt += 1
#         return Xnew

    def __len__(self):
        return len(self.simLen*self.data)


#     def plotData(self,idx,pngFile=None):
#         D = self.data[idx]
#         for i in range(4):
#             grid_z = D[i]
#             plt.figure()
#             ax = plt.gca()
#             im = ax.pcolormesh(self.grid_x,self.grid_y, grid_z, cmap='RdYlBu')
#             plt.axes().set_aspect('equal')
#             plt.title('Sample {}, {}'.format(idx,self.column[i]))
#             divider = make_axes_locatable(ax)
#             cax = divider.append_axes("right", size="5%", pad=0.05)
#             plt.colorbar(im, cax=cax)
#             if pngFile:
#                 plt.savefig(pngFile, dpi=300)
#                 plt.close()

    def __getitem__(self, idx):
        if len(self.data) == 1:
            q = 0
            r_idx = idx
        else:
            q,r = np.divmod(idx,self.simLen)
            r_idx = np.random.randint(0,self.simLen-self.w)

        X,p = self.data[q]
        x = X[r_idx:r_idx+1]
        #print(x.shape)
        y = X[r_idx+1:r_idx+self.w+1]
        #print(y.shape)
        if self.doPreprocess:
            x = self.preprocessFcn(x)
            y = self.preprocessFcn(y)

        y = np.expand_dims(y,1)
        p_x = np.hstack([p,self.t[r_idx]])
        p_y = np.vstack([p*np.ones((self.w,)),self.t[r_idx+1:r_idx+self.w+1]]).T
        X = x.astype('float32')
        Y = y.astype('float32')
        if self.AE:
            return X,X # this allows LR_finder to work
        else:
            return X, Y, p_x, p_y



class CCSI_2D_old(Dataset):
    def __init__(self,
                 dataDirec='/data/ccsi/PNNLTimeStepData/001a/',
                 numToKeep=np.infty,transform=None,preprocess=True,
                 Nx=None,Ny=None,delta_x=None,nextPow2=True,interpMethod='linear',
                 channel=None):

        self.data = []
        self.files = []
        self.delta_x = delta_x
        self.nextPow2 = nextPow2
        self.Nx = Nx
        self.Ny = Ny
        self.grid_x = []
        self.grid_y = []
        self.preprocess = preprocess
        self.interpMethod = interpMethod
        self.channel = channel

        if type(dataDirec) == list:
            self.files = dataDirec
        elif 'pkl' in dataDirec:
            with open(dataDirec,'rb') as fid:
                D = pickle.load(fid)
                self.data = np.array(D['data'])
                self.grid_x = D['grid_x']
                self.grid_y = D['grid_y']
                if numToKeep < len(self.data):
                     self.data = self.data[:numToKeep]
        else:
            files = glob(os.path.join(dataDirec,'*.csv'))
            L = np.argsort(list(map(getInt,files)))
            self.files = [files[i] for i in L]

        self.dataDirec = dataDirec
        self.numToKeep = numToKeep
        self.transform = transform
        self.preprocess = preprocess
        self.column = []


        if self.files is not []:
            if numToKeep < len(self.files):
                self.files = self.files[:numToKeep]

            for f in self.files:
                self.data.append(self.loadfile(f))

        if preprocess:
            for i, d in enumerate(self.data):
                self.data[i] = self.preprocessFcn(d)

    def loadfile(self,fn):
        D = pd.read_csv(fn)
        x = D['X (m)'].values.astype('float32')
        y = D['Y (m)'].values.astype('float32')
        X = []
        for d in D.columns[:4]:
            z = D[d].values.astype('float32')
            grid_x, grid_y, grid_z = interpData(x,y,z,
                                                self.Nx,self.Ny,
                                                self.delta_x,self.nextPow2,
                                                self.interpMethod)
            X.append(grid_z)

        self.grid_x = grid_x
        self.grid_y = grid_y
        self.column = D.columns[:4]
        return np.array(X).astype('float32')


    def preprocessFcn(self, X,mx=[5.46,4.1,1.,2012.],
                      mn=[-4.8, -8.8,0.,-1725.]):
        # mx and mn are the maximums and minimums
        # of the original data's 4 channels.
        assert len(X) == 4
        Xnew = np.empty_like(X)
        cnt = 0
        for x,M,m in zip(X,mx,mn):
            Xnew[cnt] = 2*((x-m)/(M-m) - .5)
            cnt += 1
        return Xnew

    def inversePreprocessFcn(self, X,mx=[5.46,4.1,1.,2012.],
                             mn=[-4.8, -8.8,0.,-1725.]):
        assert len(X) == 4
        Xnew = np.empty_like(X)
        cnt = 0
        for x,M,m in zip(X,mx,mn):
            Xnew[cnt] = (M - m)*((x/2) + .5) + m
            cnt += 1
        return Xnew

    def __len__(self):
        return len(self.data)


    def plotData(self,idx,pngFile=None):
        D = self.data[idx]
        for i in range(4):
            grid_z = D[i]
            plt.figure()
            ax = plt.gca()
            im = ax.pcolormesh(self.grid_x,self.grid_y, grid_z, cmap='RdYlBu')
            plt.axes().set_aspect('equal')
            plt.title('Sample {}, {}'.format(idx,self.column[i]))
            divider = make_axes_locatable(ax)
            cax = divider.append_axes("right", size="5%", pad=0.05)
            plt.colorbar(im, cax=cax)
            if pngFile:
                plt.savefig(pngFile, dpi=300)
                plt.close()

    def __getitem__(self, idx):
        X  = self.data[idx].astype('float32')
        if self.channel is not None:
            X = X[self.channel,:,:]
            X = X[np.newaxis]

        if self.transform is not None:
            X = self.transform(X)
        return X,X # this allows LR_finder to work


# these functions are in the class too
def preprocessFcn(X,mx=[5.46,4.1,1.,2012.],
                 mn=[-4.8, -8.8,0.,-1725.]):
    # maps the X to [-1,1]
    assert len(X) == 4
    Xnew = np.empty_like(X)
    cnt = 0
    for x,M,m in zip(X,mx,mn):
        Xnew[cnt] = 2*((x-m)/(M-m) - .5)
        cnt += 1
    return Xnew

def inversePreprocessFcn(X,mx=[5.46,4.1,1.,2012.],
                 mn=[-4.8, -8.8,0.,-1725.]):
    Xnew = np.empty_like(X)
    cnt = 0
    for x,M,m in zip(X,mx,mn):
        Xnew[cnt] = (M - m)*((x/2) + .5) + m
        cnt += 1
    return Xnew


def getInt(f):
    return int(f.split('_')[-1].replace('.csv',''))

#Cell
def sumLineSegments(p):
    d = p[1:] - p[:-1]
    d = np.sum(np.sqrt(np.sum(d**2,axis=1)))
    return d

def computeInterfacialArea(grid_x,grid_y,Z,alpha=.5):
    levels = np.array([alpha])
    fig, ax = plt.subplots(figsize=(10,10))
    CS = ax.contour(grid_x,grid_y,Z, levels, origin='lower')
    IA = np.sum(list(map(lambda x: sumLineSegments(x), CS.allsegs[0])))
    return IA